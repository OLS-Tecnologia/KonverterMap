{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"KonverterMap","text":"<p>KonverterMap is a lightweight, expressive and strongly-typed object mapping library for .NET.</p> <p>\u2705 A simple, fast and flexible alternative to AutoMapper \ud83e\udde0 Compatible with .NET 8 and .NET Framework 4.6.1+ (via .NET Standard 2.0)</p>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>\ud83d\udce6 Minimal setup \u2013 just map and go</li> <li>\ud83d\udd12 Strongly typed property access (<code>Expression&lt;Func&lt;&gt;&gt;</code>)</li> <li>\ud83e\udde0 Custom logic with <code>.ForMember(...)</code></li> <li>\ud83d\ude48 Property ignoring with <code>.Ignore(...)</code></li> <li>\ud83d\udd01 Bi-directional mapping with <code>.ReverseMap()</code></li> <li>\ud83e\udde9 Recursive mapping using <code>Konverter.Map(...)</code></li> <li>\ud83d\udccb Conditional mapping with <code>.When(...)</code></li> <li>\ud83d\udd04 Collections, nested objects and null safety</li> <li>\u2699\ufe0f Available as a NuGet package</li> </ul>"},{"location":"#why-konvertermap","title":"\ud83d\ude80 Why KonverterMap?","text":"<p>Many developers rely on object mapping in layered architectures (DTOs, ViewModels, Entities). KonverterMap helps you keep your code clean, testable and expressive \u2014 without reflection-heavy overhead or licensing issues.</p>"},{"location":"advanced-usage/","title":"Advanced Usage","text":""},{"location":"advanced-usage/#recursive-mapping","title":"\ud83d\udd01 Recursive Mapping","text":"<p>Use the second overload of <code>.ForMember</code> to call <code>.Map&lt;T1, T2&gt;()</code> within the expression:</p> <pre><code>.ForMember(dest =&gt; dest.Profile, (src, map) =&gt;\n    src.Profile != null ? map.Map&lt;Profile, ProfileDto&gt;(src.Profile) : null\n)\n</code></pre>"},{"location":"advanced-usage/#mapping-collections","title":"\ud83d\udccb Mapping Collections","text":"<pre><code>.ForMember(dest =&gt; dest.Items, (src, map) =&gt;\n    src.Items?.Select(i =&gt; map.Map&lt;Item, ItemDto&gt;(i)).ToList()\n)\n</code></pre> <p>Supports lists, arrays and other <code>IEnumerable&lt;&gt;</code>.</p>"},{"location":"advanced-usage/#conditional-mapping","title":"\ud83e\udde0 Conditional Mapping","text":"<pre><code>.When(dest =&gt; dest.Status, src =&gt; src.IsActive &amp;&amp; !string.IsNullOrEmpty(src.Status))\n</code></pre>"},{"location":"advanced-usage/#null-handling","title":"\u26a0\ufe0f Null Handling","text":"<p><code>KonverterMap</code> is null-safe by default. But inside custom expressions, you should still check nulls manually to avoid exceptions.</p> <pre><code>src.Address != null ? map.Map&lt;Address, AddressDto&gt;(src.Address) : null\n</code></pre>"},{"location":"advanced-usage/#deep-nested-mapping","title":"\ud83e\udde9 Deep Nested Mapping","text":"<p>Supports multi-level mapping with recursive objects, like:</p> <pre><code>Konverter.Instance.CreateMap&lt;User, UserDto&gt;()\n    .ForMember(dest =&gt; dest.Manager, (src, map) =&gt; map.Map&lt;User, UserDto&gt;(src.Manager));\n</code></pre>"},{"location":"advanced-usage/#combined-example-with-beforemap-and-aftermap","title":"\ud83d\ude80 Combined Example with BeforeMap and AfterMap","text":"<pre><code>Konverter.Instance.CreateMap&lt;User, UserDto&gt;()\n    .BeforeMap((src, dest) =&gt;\n    {\n        if (string.IsNullOrWhiteSpace(src.FirstName))\n            src.FirstName = \"Anonymous\";\n    })\n    .ForMember(dest =&gt; dest.FullName, src =&gt; $\"{src.FirstName} {src.LastName}\")\n    .AfterMap((src, dest) =&gt;\n    {\n        dest.Tag = $\"Welcome {dest.FullName}!\";\n    });\n</code></pre> <p>This setup normalizes the source, maps with custom logic, and finalizes with a post-processing step.</p>"},{"location":"changelog/","title":"\ud83d\udccb Changelog","text":"<p>Todas as altera\u00e7\u00f5es feitas neste projeto est\u00e3o listadas abaixo.</p>"},{"location":"changelog/#57255b5-2025-04-16","title":"57255b5 - 2025-04-16","text":"<ul> <li>Merge pull request #9 from OLS-Tecnologia/MapFrom</li> </ul>"},{"location":"changelog/#dc963f9-2025-04-16","title":"dc963f9 - 2025-04-16","text":"<ul> <li>Merge branch 'master' into MapFrom</li> </ul>"},{"location":"changelog/#92d638b-2025-04-16","title":"92d638b - 2025-04-16","text":"<ul> <li>Ajuste da vers\u00e3o.</li> </ul>"},{"location":"changelog/#edc13f6-2025-04-16","title":"edc13f6 - 2025-04-16","text":"<ul> <li>Atualiza\u00e7\u00e3o da documenta\u00e7\u00e3o.</li> </ul>"},{"location":"changelog/#8996e64-2025-04-16","title":"8996e64 - 2025-04-16","text":"<ul> <li>Cria\u00e7\u00e3o helper MapFrom que permite reutilizar a configura\u00e7\u00e3o de outro mapeamento dentro de outra configura\u00e7\u00e3o de mapeamento.</li> </ul>"},{"location":"changelog/#568d948-2025-04-15","title":"568d948 - 2025-04-15","text":"<ul> <li>\ud83d\udd04 Atualiza changelog da documenta\u00e7\u00e3o</li> </ul>"},{"location":"changelog/#02ada6d-2025-04-15","title":"02ada6d - 2025-04-15","text":"<ul> <li>Merge pull request #8 from OLS-Tecnologia/MelhoriaReverseMap</li> </ul>"},{"location":"changelog/#5c5eeb3-2025-04-15","title":"5c5eeb3 - 2025-04-15","text":"<ul> <li>Ajuste da vers\u00e3o</li> </ul>"},{"location":"changelog/#400acde-2025-04-15","title":"400acde - 2025-04-15","text":"<ul> <li>Melhoria no ReverseMap para que ele observe os detalhes de mapeamento aplicados e os aplique tamb\u00e9m nos casos reversos.</li> </ul>"},{"location":"changelog/#db8c9f6-2025-04-13","title":"db8c9f6 - 2025-04-13","text":"<ul> <li>Merge pull request #7 from OLS-Tecnologia/BeforeAfterMap</li> </ul>"},{"location":"changelog/#a5369e9-2025-04-13","title":"a5369e9 - 2025-04-13","text":"<ul> <li>Atualiza\u00e7\u00e3o da documenta\u00e7\u00e3o.</li> </ul>"},{"location":"changelog/#dc58522-2025-04-13","title":"dc58522 - 2025-04-13","text":"<ul> <li>Update README.md</li> </ul>"},{"location":"changelog/#0c39908-2025-04-13","title":"0c39908 - 2025-04-13","text":"<ul> <li>\ud83d\udd04 Atualiza changelog da documenta\u00e7\u00e3o</li> </ul>"},{"location":"changelog/#035976c-2025-04-13","title":"035976c - 2025-04-13","text":"<ul> <li>Merge pull request #6 from OLS-Tecnologia/BeforeAfterMap</li> </ul>"},{"location":"changelog/#65bb8f5-2025-04-13","title":"65bb8f5 - 2025-04-13","text":"<ul> <li>Atualiza\u00e7\u00e3o da documenta\u00e7\u00e3o.</li> </ul>"},{"location":"changelog/#6616d9c-2025-04-13","title":"6616d9c - 2025-04-13","text":"<ul> <li>Merge pull request #5 from OLS-Tecnologia/BeforeAfterMap</li> </ul>"},{"location":"changelog/#7ec2572-2025-04-13","title":"7ec2572 - 2025-04-13","text":"<ul> <li>Cria\u00e7\u00e3o dos m\u00e9todos before e after map no projeto.</li> </ul>"},{"location":"changelog/#db13667-2025-04-11","title":"db13667 - 2025-04-11","text":"<ul> <li>\ud83d\udd04 Atualiza changelog da documenta\u00e7\u00e3o</li> </ul>"},{"location":"changelog/#6bec25e-2025-04-11","title":"6bec25e - 2025-04-11","text":"<ul> <li>Merge pull request #4 from OLS-Tecnologia/AjusteMapeamentoRecursivo</li> </ul>"},{"location":"changelog/#df16a5a-2025-04-11","title":"df16a5a - 2025-04-11","text":"<ul> <li>Melhoria no tratamento de listas nulas para mapeamentos recursivos evitando o erro index out of bounds.</li> </ul>"},{"location":"changelog/#fca4f56-2025-04-08","title":"fca4f56 - 2025-04-08","text":"<ul> <li>\ud83d\udd04 Atualiza changelog da documenta\u00e7\u00e3o</li> </ul>"},{"location":"changelog/#8f1306f-2025-04-08","title":"8f1306f - 2025-04-08","text":"<ul> <li>Merge pull request #3 from OLS-Tecnologia/Documentacao</li> </ul>"},{"location":"changelog/#3d4123b-2025-04-08","title":"3d4123b - 2025-04-08","text":"<ul> <li>Cria\u00e7\u00e3o da p\u00e1gina para receber os changelogs do projeto para ficar dentro da documenta\u00e7\u00e3o.</li> </ul>"},{"location":"changelog/#0a5dcef-2025-04-08","title":"0a5dcef - 2025-04-08","text":"<ul> <li>Remo\u00e7\u00e3o da execu\u00e7\u00e3o do workflow de ci do merge do pull-request. Estava sendo executado duas vezes, uma na cria\u00e7\u00e3o do pull-request e outra no merge.</li> </ul>"},{"location":"changelog/#f478514-2025-04-08","title":"f478514 - 2025-04-08","text":"<ul> <li>Cria\u00e7\u00e3o da documenta\u00e7\u00e3o do projeto usando o mkdocs e o github.</li> </ul>"},{"location":"changelog/#800a2a5-2025-04-08","title":"800a2a5 - 2025-04-08","text":"<ul> <li>Verifica\u00e7\u00e3o se foi criado uma nova tag para n\u00e3o tentar enviar para o Nuget e conflitar vers\u00e3o</li> </ul>"},{"location":"changelog/#781e7d4-2025-04-08","title":"781e7d4 - 2025-04-08","text":"<ul> <li>Ajustes para gera\u00e7\u00e3o do ChangeLog</li> </ul>"},{"location":"changelog/#1c2b3c1-2025-04-08","title":"1c2b3c1 - 2025-04-08","text":"<ul> <li>Merge pull request #2 from OLS-Tecnologia/MapeamentoRecursivo</li> </ul>"},{"location":"changelog/#ad48b0d-2025-04-08","title":"ad48b0d - 2025-04-08","text":"<ul> <li>Inclus\u00e3o da possibilidade de fazer mapeamentos recursivos.</li> </ul>"},{"location":"changelog/#9b7e805-2025-04-08","title":"9b7e805 - 2025-04-08","text":"<ul> <li>Ajuste do workflow</li> </ul>"},{"location":"changelog/#fe3372a-2025-04-08","title":"fe3372a - 2025-04-08","text":"<ul> <li>Remo\u00e7\u00e3o do publish.yml e unifica\u00e7\u00e3o dos workflows em um s\u00f3 para ficar mais leg\u00edvel e f\u00e1cil a manuten\u00e7\u00e3o.</li> </ul>"},{"location":"changelog/#67f1761-2025-04-08","title":"67f1761 - 2025-04-08","text":"<ul> <li>Merge pull request #1 from OLS-Tecnologia/retro-compatibilidade</li> </ul>"},{"location":"changelog/#da2c696-2025-04-08","title":"da2c696 - 2025-04-08","text":"<ul> <li>Ajuste do workflow de release para gerar o arquivo CHANGELOG com o log do que foi gerado na vers\u00e3o em quest\u00e3o.</li> </ul>"},{"location":"changelog/#5ab7917-2025-04-08","title":"5ab7917 - 2025-04-08","text":"<ul> <li>Cria\u00e7\u00e3o do workflow para criar a tag da vers\u00e3o que est\u00e1 sendo liberada de acordo com a vers\u00e3o do arquivo csproj</li> </ul>"},{"location":"changelog/#fdc76ba-2025-04-08","title":"fdc76ba - 2025-04-08","text":"<ul> <li>Ajustes do READ.md</li> </ul>"},{"location":"changelog/#c00cedd-2025-04-08","title":"c00cedd - 2025-04-08","text":"<ul> <li>Mudan\u00e7as no c\u00f3digo para tornar o mesmo compat\u00edvel com o .net Framework a partir do 4.6.1+.</li> </ul>"},{"location":"changelog/#7c30827-2025-04-08","title":"7c30827 - 2025-04-08","text":"<ul> <li>Limpeza dos warnings do projeto.</li> </ul>"},{"location":"changelog/#983bc80-2025-04-08","title":"983bc80 - 2025-04-08","text":"<ul> <li>Ajuste da estrutura de pastas.</li> </ul>"},{"location":"changelog/#9d95f4e-2025-04-08","title":"9d95f4e - 2025-04-08","text":"<ul> <li>Remo\u00e7\u00e3o da instala\u00e7\u00e3o do teste de cobertura do ci.yml</li> </ul>"},{"location":"changelog/#c082d9d-2025-04-08","title":"c082d9d - 2025-04-08","text":"<ul> <li>Remo\u00e7\u00e3o de warnings do c\u00f3digo.</li> </ul>"},{"location":"changelog/#d254f5c-2025-04-08","title":"d254f5c - 2025-04-08","text":"<ul> <li>Remo\u00e7\u00e3o do upload-artifact</li> </ul>"},{"location":"changelog/#cad07f5-2025-04-08","title":"cad07f5 - 2025-04-08","text":"<ul> <li>Update ci.yml</li> </ul>"},{"location":"changelog/#d812afb-2025-04-08","title":"d812afb - 2025-04-08","text":"<ul> <li>Ajuste do arquivo de ci.yml para corre\u00e7\u00e3o de erro ao compilar.</li> </ul>"},{"location":"changelog/#5a5a1f7-2025-04-08","title":"5a5a1f7 - 2025-04-08","text":"<ul> <li>Ajuste do nome da Solution</li> </ul>"},{"location":"changelog/#89d83bf-2025-04-08","title":"89d83bf - 2025-04-08","text":"<ul> <li>Cria\u00e7\u00e3o da automa\u00e7\u00e3o de build ao realizar post na master.</li> </ul>"},{"location":"changelog/#7386830-2025-04-08","title":"7386830 - 2025-04-08","text":"<ul> <li>Add project files.</li> </ul>"},{"location":"changelog/#892a8de-2025-04-08","title":"892a8de - 2025-04-08","text":"<ul> <li>Add .gitattributes and .gitignore.</li> </ul>"},{"location":"config-after-map/","title":"AfterMap","text":"<p><code>AfterMap</code> runs after all mapping is completed. It is useful for setting derived fields or final adjustments.</p>"},{"location":"config-after-map/#example-1-set-combined-field","title":"\u2705 Example 1: Set combined field","text":"<pre><code>.AfterMap((src, dest) =&gt;\n{\n    dest.FullName = $\"{src.FirstName} {src.LastName}\";\n});\n</code></pre>"},{"location":"config-after-map/#example-2-audit-note","title":"\u2705 Example 2: Audit note","text":"<pre><code>.AfterMap((src, dest) =&gt;\n{\n    dest.Notes = $\"Mapped on {DateTime.Now}\";\n});\n</code></pre>"},{"location":"config-after-map/#example-3-derived-calculations","title":"\u2705 Example 3: Derived calculations","text":"<pre><code>.AfterMap((src, dest) =&gt;\n{\n    dest.IsAdult = src.Age &gt;= 18;\n});\n</code></pre>"},{"location":"config-automapping/","title":"Automatic Mapping Without Configuration","text":"<p>KonverterMap allows object-to-object mapping without requiring a prior <code>CreateMap&lt;,&gt;()</code> configuration.</p> <p>This feature simplifies development when working with simple objects or during rapid prototyping.</p>"},{"location":"config-automapping/#how-it-works","title":"\u2705 How it works","text":"<p>If the source and destination classes have:</p> <ul> <li>Properties with the same name</li> <li>And compatible or convertible types</li> </ul> <p>Then KonverterMap can map them automatically.</p>"},{"location":"config-automapping/#example-implicit-mapping","title":"\u2728 Example: Implicit Mapping","text":"<pre><code>var user = new User\n{\n    Name = \"F\u00e1bio\",\n    Email = \"fabio@example.com\"\n};\n\nvar dto = Konverter.Instance.Map&lt;User, UserDto&gt;(user);\n// Even without CreateMap&lt;User, UserDto&gt;(), this works\n</code></pre>"},{"location":"config-automapping/#when-to-use-implicit-mapping","title":"\ud83e\udde0 When to use implicit mapping?","text":"<ul> <li>For quick tests and prototypes</li> <li>When objects have matching names and types</li> <li>To reduce boilerplate in straightforward mappings</li> </ul>"},{"location":"config-automapping/#what-it-wont-do","title":"\u26a0\ufe0f What it won't do","text":"<p>Implicit mapping does not support:</p> <ul> <li><code>.ForMember(...)</code> customizations</li> <li><code>.Ignore(...)</code></li> <li><code>.When(...)</code>, <code>.BeforeMap(...)</code>, <code>.AfterMap(...)</code></li> <li><code>.ReverseMap()</code></li> </ul>"},{"location":"config-automapping/#recommendation","title":"\u2705 Recommendation","text":"<p>Use implicit mapping for:</p> <ul> <li>Simple scenarios</li> <li>Fast prototyping</li> </ul> <p>Use explicit mapping (<code>CreateMap&lt;,&gt;()</code>) for:</p> <ul> <li>Complex mappings</li> <li>Reusability and maintainability</li> <li>Full control of transformation logic</li> </ul>"},{"location":"config-before-map/","title":"BeforeMap","text":"<p><code>BeforeMap</code> allows you to run logic before the actual mapping happens.</p>"},{"location":"config-before-map/#example-1-normalize-strings","title":"\u2705 Example 1: Normalize strings","text":"<pre><code>.BeforeMap((src, dest) =&gt;\n{\n    src.FirstName = src.FirstName?.Trim();\n    src.LastName = src.LastName?.Trim();\n});\n</code></pre>"},{"location":"config-before-map/#example-2-add-default-values","title":"\u2705 Example 2: Add default values","text":"<pre><code>.BeforeMap((src, dest) =&gt;\n{\n    if (string.IsNullOrEmpty(src.Country))\n        src.Country = \"Brazil\";\n});\n</code></pre>"},{"location":"config-before-map/#example-3-initialize-lists","title":"\u2705 Example 3: Initialize lists","text":"<pre><code>.BeforeMap((src, dest) =&gt;\n{\n    src.Items ??= new List&lt;Item&gt;();\n});\n</code></pre>"},{"location":"config-create-map/","title":"CreateMap","text":"<p><code>CreateMap&lt;TSource, TDestination&gt;()</code> defines the mapping between two types. Once registered, KonverterMap can automatically copy matching properties from source to destination.</p>"},{"location":"config-create-map/#basic-example","title":"\u2705 Basic Example","text":"<pre><code>Konverter.Instance.CreateMap&lt;User, UserDto&gt;();\n</code></pre> <p>If both classes have properties with the same name and compatible types, mapping is done automatically.</p>"},{"location":"config-create-map/#example-automatic-property-matching","title":"\ud83e\uddea Example: Automatic Property Matching","text":"<pre><code>public class User { public string Name { get; set; } }\npublic class UserDto { public string Name { get; set; } }\n\nKonverter.Instance.CreateMap&lt;User, UserDto&gt;();\n</code></pre>"},{"location":"config-create-map/#example-nested-types-formember","title":"\ud83e\udde9 Example: Nested Types + ForMember","text":"<pre><code>Konverter.Instance.CreateMap&lt;User, UserDto&gt;()\n    .ForMember(dest =&gt; dest.FullName, src =&gt; $\"{src.FirstName} {src.LastName}\");\n</code></pre> <p>You can chain <code>ForMember</code>, <code>Ignore</code>, and other configuration methods after <code>CreateMap</code>.</p>"},{"location":"config-for-member/","title":"ForMember","text":"<p>The <code>ForMember</code> method lets you control how a specific destination property is populated.</p>"},{"location":"config-for-member/#example-1-concatenated-fields","title":"\u2705 Example 1: Concatenated fields","text":"<pre><code>.ForMember(dest =&gt; dest.FullName, src =&gt; $\"{src.FirstName} {src.LastName}\")\n</code></pre>"},{"location":"config-for-member/#example-2-mapping-nested-objects","title":"\u2705 Example 2: Mapping nested objects","text":"<pre><code>.ForMember(dest =&gt; dest.Address, (src, map) =&gt;\n    map.Map&lt;Address, AddressDto&gt;(src.Address))\n</code></pre>"},{"location":"config-for-member/#example-3-mapping-collections","title":"\u2705 Example 3: Mapping collections","text":"<pre><code>.ForMember(dest =&gt; dest.Products, (src, map) =&gt;\n    src.Products?.Select(p =&gt; map.Map&lt;Product, ProductDto&gt;(p)).ToList())\n</code></pre>"},{"location":"config-ignore/","title":"Ignore","text":"<p>Use <code>.Ignore(...)</code> to skip mapping a destination property.</p>"},{"location":"config-ignore/#example-1-skipping-an-audit-field","title":"\u2705 Example 1: Skipping an audit field","text":"<pre><code>.Ignore(dest =&gt; dest.CreatedDate)\n</code></pre>"},{"location":"config-ignore/#example-2-avoid-mapping-a-navigation-property","title":"\u2705 Example 2: Avoid mapping a navigation property","text":"<pre><code>.Ignore(dest =&gt; dest.ParentCategory)\n</code></pre>"},{"location":"config-ignore/#example-3-prevent-cyclic-reference","title":"\u2705 Example 3: Prevent cyclic reference","text":"<pre><code>.Ignore(dest =&gt; dest.InverseNavigation)\n</code></pre>"},{"location":"config-mapfrom/","title":"Using <code>MapFrom</code> for Recursive and Custom Mapping","text":"<p>The <code>MapFrom</code> helper allows you to reuse existing mappings inside another mapping configuration. It's especially useful for nested objects and collections, and provides functionality similar to AutoMapper's <code>context.Mapper.Map(...)</code>.</p>"},{"location":"config-mapfrom/#what-does-it-do","title":"\ud83e\udde0 What does it do?","text":"<p>It gives you access to the Konverter instance within a <code>ForMember</code> call, so you can call:</p> <pre><code>konverter.Map&lt;TSource, TDestination&gt;(source)\n</code></pre> <p>inside a mapping delegate.</p>"},{"location":"config-mapfrom/#how-to-use","title":"\u2705 How to use","text":""},{"location":"config-mapfrom/#option-1-using-using-static","title":"Option 1: Using <code>using static</code>","text":"<p>To enable direct use of <code>MapFrom</code> without the <code>Map.</code> prefix:</p> <pre><code>using static KonverterMap.Map;\n\nKonverter.Instance.CreateMap&lt;Filial, FilialDTO&gt;()\n    .ForMember(dest =&gt; dest.Cidade,\n        MapFrom&lt;Filial, Cidade, CidadeDTO&gt;(src =&gt; src.Cidade))\n    .ForMember(dest =&gt; dest.Empresa,\n        MapFrom&lt;Filial, Empresa, EmpresaDTO&gt;(src =&gt; src.Empresa));\n</code></pre>"},{"location":"config-mapfrom/#option-2-without-using-static","title":"Option 2: Without <code>using static</code>","text":"<p>Use the full prefix when not importing the helper statically:</p> <pre><code>Konverter.Instance.CreateMap&lt;Filial, FilialDTO&gt;()\n    .ForMember(dest =&gt; dest.Cidade,\n        Map.MapFrom&lt;Filial, Cidade, CidadeDTO&gt;(src =&gt; src.Cidade))\n    .ForMember(dest =&gt; dest.Empresa,\n        Map.MapFrom&lt;Filial, Empresa, EmpresaDTO&gt;(src =&gt; src.Empresa));\n</code></pre>"},{"location":"config-mapfrom/#reversemap-compatibility","title":"\ud83d\udd04 ReverseMap compatibility","text":"<p>If you call <code>.ReverseMap()</code> and you\u2019ve already configured:</p> <pre><code>CreateMap&lt;Cidade, CidadeDTO&gt;().ReverseMap();\nCreateMap&lt;Empresa, EmpresaDTO&gt;().ReverseMap();\n</code></pre> <p>The <code>MapFrom</code> references will work automatically in both directions.</p>"},{"location":"config-mapfrom/#full-working-example","title":"\ud83e\uddea Full working example","text":"<pre><code>Konverter.Instance.CreateMap&lt;Cidade, CidadeDTO&gt;().ReverseMap();\nKonverter.Instance.CreateMap&lt;Empresa, EmpresaDTO&gt;().ReverseMap();\n\nKonverter.Instance.CreateMap&lt;Filial, FilialDTO&gt;()\n    .ForMember(dest =&gt; dest.Cidade,\n        Map.MapFrom&lt;Filial, Cidade, CidadeDTO&gt;(src =&gt; src.Cidade))\n    .ForMember(dest =&gt; dest.Empresa,\n        Map.MapFrom&lt;Filial, Empresa, EmpresaDTO&gt;(src =&gt; src.Empresa))\n    .ReverseMap();\n</code></pre> <p>This enables recursive, clean, and safe mapping for nested objects.</p>"},{"location":"config-reverse-map/","title":"ReverseMap","text":"<p><code>.ReverseMap()</code> automatically registers the reverse mapping, inverting source and destination types.</p>"},{"location":"config-reverse-map/#example","title":"\u2705 Example","text":"<pre><code>Konverter.Instance.CreateMap&lt;User, UserDto&gt;()\n                 .ReverseMap();\n</code></pre>"},{"location":"config-reverse-map/#useful-for","title":"\ud83d\udd01 Useful for:","text":"<ul> <li>DTO &lt;-&gt; Entity</li> <li>FormModel &lt;-&gt; Model</li> <li>ViewModel &lt;-&gt; Domain</li> </ul>"},{"location":"config-when/","title":"When","text":"<p>The <code>When</code> method allows conditional mapping: a destination property is mapped only if the condition returns true.</p>"},{"location":"config-when/#example-1-map-only-if-status-is-active","title":"\u2705 Example 1: Map only if status is active","text":"<pre><code>.When(dest =&gt; dest.IsActive, src =&gt; src.Status == \"ACTIVE\")\n</code></pre>"},{"location":"config-when/#example-2-skip-if-value-is-null-or-empty","title":"\u2705 Example 2: Skip if value is null or empty","text":"<pre><code>.When(dest =&gt; dest.Description, src =&gt; !string.IsNullOrEmpty(src.Description))\n</code></pre>"},{"location":"config-when/#example-3-apply-condition-on-numeric-fields","title":"\u2705 Example 3: Apply condition on numeric fields","text":"<pre><code>.When(dest =&gt; dest.Discount, src =&gt; src.Discount &gt; 0)\n</code></pre>"},{"location":"configuration/","title":"Configuration","text":""},{"location":"configuration/#createmap","title":"\ud83d\udee0 CreateMap","text":"<p>Registers a mapping between two types.</p> <pre><code>Konverter.Instance.CreateMap&lt;Source, Destination&gt;();\n</code></pre> <p>If both types have properties with the same name and type, the mapping is automatic.</p>"},{"location":"configuration/#formember","title":"\ud83e\udde0 ForMember","text":"<p>Define a custom mapping for a specific property.</p>"},{"location":"configuration/#basic-example","title":"\ud83d\udca1 Basic Example","text":"<pre><code>.ForMember(dest =&gt; dest.FullName, src =&gt; $\"{src.FirstName} {src.LastName}\")\n</code></pre>"},{"location":"configuration/#recursive-mapping","title":"\ud83d\udca1 Recursive Mapping","text":"<pre><code>.ForMember(dest =&gt; dest.Address, (src, map) =&gt;\n    map.Map&lt;Address, AddressDto&gt;(src.Address)\n)\n</code></pre>"},{"location":"configuration/#list-mapping","title":"\ud83d\udca1 List Mapping","text":"<pre><code>.ForMember(dest =&gt; dest.Orders, (src, map) =&gt;\n    src.Orders?.Select(o =&gt; map.Map&lt;Order, OrderDto&gt;(o)).ToList()\n)\n</code></pre>"},{"location":"configuration/#ignore","title":"\ud83d\ude48 Ignore","text":"<p>Skips a property from being mapped.</p> <pre><code>.Ignore(dest =&gt; dest.Password)\n</code></pre>"},{"location":"configuration/#when","title":"\ud83e\uddea When","text":"<p>Maps a property only if a condition is true.</p> <pre><code>.When(dest =&gt; dest.Status, src =&gt; src.IsActive)\n</code></pre>"},{"location":"configuration/#reversemap","title":"\ud83d\udd01 ReverseMap","text":"<p>Registers the reverse mapping automatically.</p> <pre><code>Konverter.Instance.CreateMap&lt;User, UserDto&gt;().ReverseMap();\n</code></pre> <p>Equivalent to:</p> <pre><code>Konverter.Instance.CreateMap&lt;User, UserDto&gt;();\nKonverter.Instance.CreateMap&lt;UserDto, User&gt;();\n</code></pre>"},{"location":"configuration/#beforemap","title":"\ud83e\udde9 BeforeMap","text":"<p>Executes a function before the mapping starts.</p> <pre><code>.BeforeMap((src, dest) =&gt;\n{\n    if (string.IsNullOrWhiteSpace(src.FirstName))\n        src.FirstName = \"Unknown\";\n});\n</code></pre> <p>Useful for: - Normalizing data - Assigning default values - Preparing data structures</p>"},{"location":"configuration/#aftermap","title":"\ud83c\udfaf AfterMap","text":"<p>Executes a function after the mapping is completed.</p> <pre><code>.AfterMap((src, dest) =&gt;\n{\n    dest.FullName = $\"{src.FirstName} {src.LastName}\";\n});\n</code></pre> <p>Useful for: - Concatenating mapped values - Populating derived fields - Final adjustments</p>"},{"location":"exemplo-nome-completo/","title":"Example: User with Full Name","text":"<pre><code>Konverter.Instance.CreateMap&lt;User, UserDto&gt;()\n    .ForMember(dest =&gt; dest.FullName, src =&gt; $\"{src.FirstName} {src.LastName}\");\n</code></pre> <p>Useful when source has separate name fields and you want to concatenate.</p>"},{"location":"exemplo-pedidos/","title":"Example: Mapping Order List","text":"<pre><code>Konverter.Instance.CreateMap&lt;Customer, CustomerDto&gt;()\n    .ForMember(dest =&gt; dest.Orders, (src, map) =&gt;\n        src.Orders?.Select(o =&gt; map.Map&lt;Order, OrderDto&gt;(o)).ToList());\n</code></pre> <p>Automatically maps a list of child objects using the existing registered mapping.</p>"},{"location":"exemplo-pessoa-responsavel/","title":"Example: Recursive Pessoa \u2192 Respons\u00e1vel","text":"<pre><code>Konverter.Instance.CreateMap&lt;Pessoa, Pessoa&gt;()\n    .ForMember(dest =&gt; dest.Responsavel, (src, map) =&gt;\n        src.Responsavel != null ? map.Map&lt;Pessoa, Pessoa&gt;(src.Responsavel) : null)\n    .Ignore(dest =&gt; dest.InverseIdResponsavelNavigation);\n</code></pre> <p>Demonstrates recursion and ignoring back-reference.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"\ud83d\udce6 Installation","text":"<p>Install via NuGet:</p> <pre><code>dotnet add package KonverterMap\n</code></pre> <p>Or manually edit your <code>.csproj</code>:</p> <pre><code>&lt;PackageReference Include=\"KonverterMap\" Version=\"1.0.1\" /&gt;\n</code></pre>"},{"location":"getting-started/#first-map","title":"\ud83d\ude80 First Map","text":"<p>Suppose you have two classes:</p> <pre><code>public class User\n{\n    public string FirstName { get; set; }\n    public string LastName { get; set; }\n}\n\npublic class UserDto\n{\n    public string FullName { get; set; }\n}\n</code></pre>"},{"location":"getting-started/#setup-the-map","title":"\ud83d\udd27 Setup the map","text":"<pre><code>Konverter.Instance.CreateMap&lt;User, UserDto&gt;()\n    .ForMember(dest =&gt; dest.FullName, src =&gt; $\"{src.FirstName} {src.LastName}\");\n</code></pre>"},{"location":"getting-started/#execute-mapping","title":"\u25b6\ufe0f Execute mapping","text":"<pre><code>var user = new User { FirstName = \"John\", LastName = \"Doe\" };\nvar dto = Konverter.Instance.Map&lt;User, UserDto&gt;(user);\nConsole.WriteLine(dto.FullName); // John Doe\n</code></pre>"},{"location":"handling-collections/","title":"Handling collections","text":"<p>\ud83d\udcd8 Handling Collections and Preventing Cycles markdown Copiar Editar</p>"},{"location":"handling-collections/#handling-collections-and-preventing-cycles","title":"Handling Collections and Preventing Cycles","text":"<p>KonverterMap automatically handles mapping for collection properties in a safe and efficient way. Starting from version X.X.X, important improvements were added to prevent infinite loops and preserve performance during recursive mapping.</p>"},{"location":"handling-collections/#collection-detection","title":"\u2705 Collection Detection","text":"<p>The internal method <code>IsCollection(Type type)</code> recognizes the following types as collections:</p> <ul> <li><code>List&lt;T&gt;</code></li> <li><code>IEnumerable&lt;T&gt;</code></li> <li><code>ICollection&lt;T&gt;</code></li> <li><code>HashSet&lt;T&gt;</code></li> <li>Arrays (<code>T[]</code>)</li> <li><code>ObservableCollection&lt;T&gt;</code>, and similar</li> </ul> <p>\u2757 <code>string</code> and <code>ArrayList</code> are excluded to avoid false positives.</p>"},{"location":"handling-collections/#element-type-extraction","title":"\u2705 Element Type Extraction","text":"<p>The method <code>ExtractElementType(Type collectionType)</code> safely extracts the element type from generic collections or arrays.</p> <p>If the provided type is not a recognized collection, an <code>InvalidOperationException</code> is thrown.</p>"},{"location":"handling-collections/#cycle-prevention","title":"\ud83d\udd01 Cycle Prevention","text":"<p>KonverterMap internally uses a dictionary (<code>alreadyInitializedObjects</code>) to:</p> <ul> <li>Track which objects have already been mapped</li> <li>Temporarily mark objects being processed as <code>null!</code> to detect recursion</li> <li>Prevent infinite loops in circular references such as:</li> </ul> <p>```csharp Pessoa \u2192 PessoaEndereco \u2192 Cidade \u2192 Uf \u2192 Cidades \u2192 PessoaEndereco \ud83d\udd04 Direct Copy for Identical Types If the source and destination property types are exactly the same, KonverterMap will assign the object directly instead of recursively mapping it again.</p> <p>This improves performance and reduces overhead.</p> <p>\ud83e\udde0 Example csharp Copiar Editar public class PessoaEndereco {     public Cidade Cidade { get; set; } }</p> <p>public class Cidade {     public Uf Uf { get; set; } }</p> <p>public class Uf {     public ICollection Cidades { get; set; } // circular reference! } When mapping PessoaEndereco, KonverterMap will safely avoid remapping the same circular path Cidade \u2192 Uf \u2192 Cidades, preventing StackOverflowException."}]}